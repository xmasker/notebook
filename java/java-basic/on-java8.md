# 一、对象的概念

## （1）“纯粹”的面向对象程序设计方法

1. 万物皆对象。你可以将对象想象成一种特殊的变量。它存储数据，但可以在你对其“发出请求”时执行本身的操作。

2. 程序是一组对象，通过消息传递来告知彼此该做什么。要请求调用一个对象的方法，你需要向该对象发送消息。

3. 每个对象都有自己的存储空间，可容纳其他对象。或者说，通过封装现有对象，可制作出新型对象。

4. 每个对象都有一种类型。根据语法，每个对象都是某个“类”的一个“实例”。其中，“类”（Class）是“类型”（Type）的同义词。一个类最重要的特征就是“能将什么消息发给它？”。

5. 同一类所有对象都能接收相同的消息。由于类型为“圆”（Circle）的一个对象也属于类型为“形状”（Shape）的一个对象，所以一个圆完全能接收发送给“形状”的消息。这意味着可让程序代码统一指挥“形状”，令其自动控制所有符合“形状”描述的对象，其中自然包括“圆”。这一特性称为对象的“可替换性”，是OOP最重要的概念之一。

一个对象具有自己的状态，行为和标识。这意味着对象有自己的内部数据(提供状态)、方法(产生行为)，并彼此区分（每个对象在内存中都有唯一的地址）。

## （2）封装

**原因：**

1. 让应用程序员不要触摸他们不应该触摸的部分。

2. 使类库的创建者（研发程序员）在不影响后者使用的情况下完善更新工具库。



Java 有三个显式关键字来设置类中的访问权限：public（公开），private（私有）和protected（受保护）。访问修饰符决定了谁能使用它们修饰的方法、变量或类。

1. public（公开）表示任何人都可以访问和使用该元素；

2. private（私有）除了类本身和类内部的方法，外界无法直接访问该元素。private是类和调用者之间的屏障。任何试图访问私有成员的行为都会报编译时错误；

3. protected（受保护）类似于private，区别是子类可以访问protected的成员，但不能访问private成员；

4. default（默认）如果你不使用前面的三者，默认就是default访问权限。default被称为包访问，因为该权限下的资源可以被同一包（库组件）中其他类的成员访问。

## （3）复用

新的类可以是由任意数量和任意类型的其他对象构成。这里涉及到“组合”和“聚合”的概念：

组合（Composition）经常用来表示“拥有”关系（has-a relationship）。例如，“汽车拥有引擎”。

聚合（Aggregation）动态的组合。

聚合关系中，整件不会拥有部件的生命周期，所以整件删除时，部件不会被删除。再者，多个整件可以共享同一个部件。

组合关系中，整件拥有部件的生命周期，所以整件删除时，部件一定会跟着删除。而且，多个整件不可以同时共享同一个部件。这个区别可以用来区分某个关联关系到底是组合还是聚合。两个类生命周期不同步，则是聚合关系，生命周期同步就是组合关系。

新类时首先要考虑“组合”，因为它更简单灵活，而且设计更加清晰。

## （4）继承

从现有类型继承创建新类型。这种新类型不仅包含现有类型的所有成员（尽管私有成员被隐藏起来并且不可访问），而且更重要的是它复制了基类的接口。也就是说，基类对象接收的所有消息也能被派生类对象接收。

## （5）多态

在处理类的层次结构时，通常把一个对象看成是它所属的基类，而不是把它当成具体类。通过这种方式，我们可以编写出不局限于特定类型的代码。

在传统意义上，编译器不能进行函数调用。由非OOP编译器产生的函数调用会引起所谓的早期绑定。这意味着编译器生成对特定函数名的调用，该调用会被解析为将执行的代码的绝对地址。通过继承，程序直到运行时才能确定代码的地址，因此发送消息给对象时，还需要其他一些方案。

面向对象语言使用后期绑定的概念。当向对象发送信息时，被调用的代码直到运行时才确定。编译器确保方法存在，并对参数和返回值执行类型检查，但是它不知道要执行的确切代码。

为了执行后期绑定，Java使用一个特殊的代码位来代替绝对调用。这段代码使用对象中存储的信息来计算方法主体的地址。因此，每个对象的行为根据特定代码位的内容而不同。当你向对象发送消息时，对象知道该如何处理这条消息。在某些语言中，必须显式地授予方法后期绑定属性的灵活性。例如，C++使用virtual关键字。在这些语言中，默认情况下方法不是动态绑定的。在Java中，动态绑定是默认行为，不需要额外的关键字来实现多态性。

把子类当成其基类来处理的过程叫做“向上转型”（upcasting）。在面向对象的编程里，经常利用这种方法来给程序解耦。

发送消息给对象时，如果程序不知道接收的具体类型是什么，但最终执行是正确的，这就是对象的“多态性”（Polymorphism）。面向对象的程序设计语言是通过“动态绑定”的方式来实现对象的多态性的。编译器和运行时系统会负责对所有细节的控制；我们只需知道要做什么，以及如何利用多态性来更好地设计程序。

## （6）单继承

在Java中，最终基类的名字就是Object。Java的单继承结构有很多好处。由于所有对象都具有一个公共接口，因此它们最终都属于同一个基类。相反的，对于C++所使用的多继承的方案则是不保证所有的对象都属于同一个基类。从向后兼容的角度看，多继承的方案更符合C的模型，而且受限较少。

单继承的结构使得垃圾收集器的实现更为容易。这也是Java在C++基础上的根本改进之一。

由于运行期的类型信息会存在于所有对象中，所以我们永远不会遇到判断不了对象类型的情况。这对于系统级操作尤其重要，例如异常处理。

## （7）集合

不知道解决某个具体问题需要的对象数量和持续时间，以及对象的存储方式。那么我们如何知悉程序在运行时需要分配的内存空间呢？

在面向对象的设计中，问题的解决方案有些过于轻率：创建一个新类型的对象来引用、容纳其他的对象。当然，我们也可以使用多数编程语言都支持的“数组”（array）。在Java中“集合”（Collection）的使用率更高。（也可称之为“容器”，但“集合”这个称呼更通用。）

“集合”这种类型的对象可以存储任意类型、数量的其他对象。它能根据需要自动扩容，我们不用关心过程是如何实现的。

常见的有List，常用于保存序列；Map，也称为关联数组，常用于将对象与其他对象关联；Set，只能保存非重复的值；其他还包括如队列（Queue）、树（Tree）、栈（Stack）、堆（Heap）等等。

由于Java 5版本前的集合只保存Object，当我们往集合中添加元素时，元素便向上转型成了Object，从而丢失自己原有的类型特性。这时我们再从集合中取出该元素时，元素的类型变成了Object。以某种方式创建集合，以确认保存元素的具体类型，减少集合元素“向下转型”的开销和可能出现的错误难道不好吗？这种解决方案就是：参数化类型机制（Parameterized Type Mechanism）。参数化类型机制可以使得编译器能够自动识别某个class的具体类型并正确地执行。举个例子，对集合的参数化类型机制可以让集合仅接受“形状”这种类型的元素，并以“形状”类型取出元素。Java 5版本支持了参数化类型机制，称之为“泛型”（Generic）。泛型是Java 5的主要特性之一。

## （8）对象创建与生命周期

在使用对象时要注意的一个关键问题就是对象的创建和销毁方式。每个对象的生存都需要资源，尤其是内存。为了资源的重复利用，当对象不再被使用时，我们应该及时释放资源，清理内存。

对象的数据在哪？它的生命周期是怎么被控制的？在C++设计中采用的观点是效率第一，因此它将选择权交给了程序员。为了获得最大的运行时速度，程序员可以在编写程序时，通过将对象放在栈（Stack，有时称为自动变量或作用域变量）或静态存储区域（static storage area）中来确定内存占用和生存时间。这些区域的对象会被优先分配内存和释放。这种控制在某些情况下非常有用。然而相对的，我们也牺牲了程序的灵活性。因为在编写代码时，我们必须要弄清楚对象的数量、生存时间还有类型。

第二种方法是在堆内存（Heap）中动态地创建对象。在这种方式下，直到程序运行我们才能确定需要创建的对象数量、生存时间和类型。什么时候需要，什么时候在堆内存中创建。因为内存的占用是动态管理的，所以在运行时，在堆内存上开辟空间所需的时间可能比在栈内存上要长（但也不一定）。在栈内存开辟和释放空间通常是一条将栈指针向下移动和一条将栈指针向上移动的汇编指令。开辟堆内存空间的时间取决于内存机制的设计。

动态方法有这样一个合理假设：对象通常是复杂的，相比于对象创建的整体开销，寻找和释放内存空间的开销微不足道。

Java使用动态内存分配。每次创建对象时，使用new关键字构建该对象的动态实例。较之堆内存，在栈内存中创建对象，编译器能够确定该对象的生命周期并自动销毁它；然而如果你在堆内存创建对象的话，编译器是不知道它的生命周期的。在C++中你必须以编程方式确定何时销毁对象，否则可能导致内存泄漏。Java的内存管理是建立在垃圾收集器上的，它能自动发现对象不再被使用并释放内存。

## （9）异常处理

异常处理机制将程序错误直接交给编程语言甚至是操作系统。“异常”（Exception）是一个从出错点“抛出”（thrown）后能被特定类型的异常处理程序捕获(catch)的一个对象。它不会干扰程序的正常运行，仅当程序出错的时候才被执行。这让我们的编码更简单：不用再反复检查错误了。



# 二、万物皆对象

## （1）对象操纵

所有的编程语言都会操纵内存中的元素。有时程序员必须要有意识地直接或间接地操纵它们。在C/C++中，对象的操纵是通过指针来完成的。

Java利用万物皆对象的思想和单一一致的语法方式来简化问题。虽万物皆可为对象，但我们所操纵的标识符实际上只是对对象的“引用”。举例：我们可以用遥控器（引用）去操纵电视（对象）。只要拥有对象的“引用”，就可以操纵该“对象”。换句话说，我们无需直接接触电视，就可通过遥控器（引用）自由地控制电视（对象）的频道和音量。此外，没有电视，遥控器也可以单独存在。就是说，你仅仅有一个“引用”并不意味着你必然有一个与之关联的“对象”。

String s;这里我们只是创建了一个String对象的引用，而非对象。直接拿来使用会出现错误：因为此时你并没有给变量s赋值–指向任何对象。

## （2）对象创建

“引用”用来关联“对象”。在Java中，通常我们使用new操作符来创建一个新对象。new关键字代表：创建一个新的对象实例。

### **数据存储**

程序在运行时是如何存储的呢？尤其是内存是怎么分配的。有5个不同的地方可以存储数据

1. 寄存器（Registers）最快的存储区域，位于CPU内部2。然而，寄存器的数量十分有限，所以寄存器根据需求进行分配。我们对其没有直接的控制权，也无法在自己的程序里找到寄存器存在的踪迹（另一方面，C/C++允许开发者向编译器建议寄存器的分配）。
2. 栈内存（Stack）存在于常规内存RAM（随机访问存储器，Random Access Memory）区域中，可通过栈指针获得处理器的直接支持。栈指针下移分配内存，上移释放内存。这是一种仅次于寄存器的非常快速有效的分配存储方式。创建程序时，Java系统必须知道栈内保存的所有项的生命周期。这种约束限制了程序的灵活性。因此，虽然在栈内存上存在一些Java数据（如对象引用），但Java对象本身的数据却是保存在堆内存的。
3. 堆内存（Heap）这是一种通用的内存池（也在RAM区域），所有Java对象都存在于其中。与栈内存不同，编译器不需要知道对象必须在堆内存上停留多长时间。因此，用堆内存保存数据更具灵活性。创建一个对象时，只需用new命令实例化对象即可，当执行代码时，会自动在堆中进行内存分配。这种灵活性是有代价的：分配和清理堆内存要比栈内存需要更多的时间（如果可以用Java在栈内存上创建对象，就像在C++中那样的话）。随着时间的推移，Java的堆内存分配机制现在已经非常快，因此这不是一个值得关心的问题了。
4. 常量存储（Constant storage）常量值通常直接放在程序代码中，因为它们永远不会改变。如需严格保护，可考虑将它们置于只读存储器ROM（只读存储器，ReadOnly Memory）中。
5. 非RAM存储（Non-RAM storage）数据完全存在于程序之外，在程序未运行以及脱离程序控制后依然存在。两个主要的例子：（1）序列化对象：对象被转换为字节流，通常被发送到另一台机器；（2）持久化对象：对象被放置在磁盘上，即使程序终止，数据依然存在。这些存储的方式都是将对象转存于另一个介质中，并在需要时恢复成常规的、基于RAM的对象。Java为轻量级持久化提供了支持。而诸如JDBC和Hibernate这些类库为使用数据库存储和检索对象信息提供了更复杂的支持。

### 基本类型的存储

需要特殊对待，这就是Java的基本类型。它们的创建并不是通过new关键字来产生。通常new出来的对象都是保存在堆内存中的，以此方式创建小而简单的变量往往是不划算的。所以对于这些基本类型的创建方法，Java使用了和C/C++一样的策略。也就是说，不是使用new创建变量，而是使用一个“自动”变量。这个变量直接存储“值”，并置于栈内存中，因此更加高效。一个例子是字符串常量池。所有文字字符串和字符串值常量表达式都会自动放入特殊的静态存储中。

Java确定了每种基本类型的内存占用大小。这些大小不会像其他一些语言那样随着机器环境的变化而变化。这种不变性也是Java更具可移植性的一个原因。

所有的数值类型都是有正/负符号的。布尔（boolean）类型的大小没有明确的规定，通常定义为取字面值“true”或“false”。基本类型有自己对应的包装类型，如果你希望在堆内存里表示基本类型的数据，就需要用到它们的包装类。

### 数组的存储

在C和C++中使用数组是危险的，因为那些数组只是内存块。如果程序访问了内存块之外的数组或在初始化之前使用该段内存（常见编程错误），则结果是不可预测的。

Java的设计主要目标之一是安全性，因此许多困扰C和C++程序员的问题不会在Java中再现。在Java中，数组使用前需要被初始化，并且不能访问数组长度以外的数据。这种范围检查，是以每个数组上少量的内存开销及运行时检查下标的额外时间为代价的，但由此换来的安全性和效率的提高是值得的。（并且Java经常可以优化这些操作）。

当我们创建对象数组时，实际上是创建了一个引用数组，并且每个引用的初始值都为null。在使用该数组之前，我们必须为每个引用指定一个对象。如果我们尝试使用为null的引用，则会在运行时报错。因此，在Java中就防止了数组操作的常规错误。

## （3）对象清理

在一些编程语言中，管理变量的生命周期需要大量的工作。一个变量需要存活多久？如果我们想销毁它，应该什么时候去做呢？变量生命周期的混乱会导致许多bug。

大多数程序语言都有作用域的概念。作用域决定了在该范围内定义的变量名的可见性和生存周期。在C、C++和Java中，作用域是由大括号{}的位置决定的。

对象作用域。Java对象与基本类型具有不同的生命周期。使用new关键字来创建Java对象时，它的生命周期将会超出作用域。

{String s =newString("a string");}//作用域。引用s在作用域终点就结束了。但是，引用s指向的字符串对象依然还在占用内存。在这段代码中，我们无法在这个作用域之后访问这个对象，因为唯一对它的引用s已超出了作用域的范围。

我们在Java中并没有主动清理这些对象，那么它是如何避免C++中出现的内存被填满从而阻塞程序的问题呢？答案是：Java的垃圾收集器会检查所有new出来的对象并判断哪些不再可达，继而释放那些被占用的内存，供其他新的对象使用。也就是说，我们不必担心内存回收的问题了。你只需简单创建对象即可。当其不再被需要时，能自行被垃圾收集器释放。垃圾回收机制有效防止了因程序员忘记释放内存而造成的“内存泄漏”问题。

## （4）类的创建

**类型**	一切都是对象，那么是什么决定了某一类对象的外观和行为呢？换句话说，是什么确定了对象的类型？你可能很自然地想到type关键字。但是，事实上大多数面向对象的语言都使用class关键字类来描述一种新的对象。

**字段**	创建好一个类之后，我们可以往类里存放两种类型的元素：方法（method）和字段（field）。类的字段可以是基本类型，也可以是引用类型。如果类的字段是对某个对象的引用，那么必须要初始化该引用将其关联到一个实际的对象上（通过之前介绍的创建对象的方法）。每个对象都有用来存储其字段的空间。通常，字段不在对象间共享。

**基本类型默认值**	如果类的成员变量（字段）是基本类型，那么在类初始化时，这些类型将会被赋予一个初始值。这些默认值仅在Java初始化类的时候才会被赋予。这种方式确保了基本类型的字段始终能被初始化（在C++中不会），从而减少了bug的来源。但是，这些初始值对于程序来说并不一定是合法或者正确的。所以，为了安全，我们最好始终显式地初始化变量。这种默认值的赋予并不适用于局部变量——那些不属于类的字段的变量。

**方法使用**	在许多语言（如C和C++）中，使用术语函数(function)用来命名子程序。在Java中，我们使用术语方法（method）来表示“做某事的方式”。在Java中，方法决定对象能接收哪些消息。方法的基本组成部分包括名称、参数、返回类型、方法体。

**返回类型**	方法的返回类型表明了当你调用它时会返回的结果类型。参数列表则显示了可被传递到方法内部的参数类型及名称。方法名和参数列表统称为方法签名（signature of themethod）。签名作为方法的唯一标识。Java中的方法只能作为类的一部分创建。它只能被对象所调用，并且该对象必须有权限来执行调用。若对象调用错误的方法，则程序将在编译时报错。调用方法的行为有时被称为向对象发送消息。面向对象编程可以总结为：向对象发送消息。

**参数列表**	方法参数列表指定了传递给方法的信息。这些信息就像Java中的其他所有信息，以对象的形式传递。参数列表必须指定每个对象的类型和名称。同样，我们并没有直接处理对象，而是在传递对象引用。但是引用的类型必须是正确的。如果方法需要String参数，则必须传入String，否则编译器将报错。通常来说，传递对象就意味者传递对象的引用。

## （5）程序编写

**命名可见性**	命名控制在任何一门编程语言中都是一个问题。如果你在两个模块中使用相同的命名，那么如何区分这两个名称，并防止两个名称发生“冲突”呢？

在C语言编程中这是很具有挑战性的，因为程序通常是一个无法管理的名称海洋。C++将函数嵌套在类中，所以它们不会和嵌套在其他类中的函数名冲突。然而，C++还是允许全局数据和全局函数，因此仍有可能发生冲突。为了解决这个问题，C++使用附加的关键字引入了命名空间。Java采取了一种新的方法避免了以上这些问题：为一个类库生成一个明确的名称，Java创建者希望我们反向使用自己的网络域名，因为域名通常是唯一的。因此我的域名是MindviewInc.com，所以我将我的foibles类库命名为com.mindviewinc.utility.foibles。反转域名后，.用来代表子目录的划分。此机制意味着所有文件都自动存在于自己的命名空间中，文件中的每个类都具有唯一标识符。这样，Java语言可以防止名称冲突。

**使用其他组件**	必须通过使用import关键字来告诉Java编译器具体要使用的类。import指示编译器导入一个包，也就是一个类库（在其他语言中，一个库不仅包含类，还可能包括函数和数据，但请记住Java中的所有代码都必须写在类里）。大多数时候，我们都在使用Java标准库中的组件。有了这些构件，你就不必写一长串的反转域名。

**static关键字**	类是对象的外观及行为方式的描述。通常只有在使用new创建那个类的对象后，数据存储空间才被分配，对象的方法才能供外界调用。这种方式在两种情况下是不足的。1.有时你只想为特定字段（注：也称为属性、域）分配一个共享存储空间，而不去考虑究竟要创建多少对象，甚至根本就不创建对象。2.创建一个与此类的任何对象无关的方法。也就是说，即使没有创建对象，也能调用该方法。

static关键字（从C++采用）就符合上述两点要求。当我们说某个事物是静态时，就意味着该字段或方法不依赖于任何特定的对象实例。即使我们从未创建过该类的对象，也可以调用其静态方法或访问其静态字段。相反，对于普通的非静态字段和方法，我们必须要先创建一个对象并使用该对象来访问字段或方法，因为非静态字段和方法必须与特定对象关联。

静态方法在使用之前不需要创建对象，因此它们不能直接调用非静态的成员或方法（因为非静态成员和方法必须要先实例化为对象才可以被使用）。

相比非静态的对象，static属性改变了数据创建的方式。同样，当static关键字修饰方法时，它允许我们无需创建对象就可以直接通过类的引用来调用该方法。static关键字的这些特性对于应用程序入口点的main()方法尤为重要。

# 三、运算符

## （1）开始使用

运算符接受一个或多个参数并生成新值。这个参数与普通方法调用的形式不同，但效果是相同的。所有运算符都能根据自己的运算对象生成一个值。除此以外，一些运算符可改变运算对象的值，这叫作“副作用”（Side Effect）。运算符最常见的用途就是修改自己的运算对象，从而产生副作用。但要注意生成的值亦可由没有副作用的运算符生成。几乎所有运算符都只能操作基本类型（Primitives）。唯一的例外是=、==和!=，它们能操作所有对象（这也是令人混淆的一个地方）。除此以外，String类支持+和+=。

## （2）优先级

## （3）复制

左边必须是一个明确的、已命名的变量。也就是说，必须要有一个物理的空间来存放右边的值。基本类型的赋值都是直接的，而不像对象，赋予的只是其内存的引用。举个例子，a= b，如果b是基本类型，那么赋值操作会将b的值复制一份给变量a，此后若a的值发生改变是不会影响到b的。如果是为对象赋值，那么结果就不一样了。对一个对象进行操作时，我们实际上操作的是它的引用。所以我们将右边的对象赋予给左边时，赋予的只是该对象的引用。此时，两者指向的堆中的对象还是同一个。

## （4）算数运算符

整数除法会直接砍掉小数，而不是进位。

**测试对象等价**	==和!=比较的是对象引用。Integer内部维护着一个IntegerCache的缓存，默认缓存范围是[-128, 127]。怎么比较两个对象的内容是否相同呢？你必须使用所有对象（不包括基本类型）中都存在的equals()方法。

equals()的默认行为是比较对象的引用而非具体内容。因此，除非你在新类中覆写equals()方法，否则我们将获取不到想要的结果。大多数Java库类通过覆写equals()方法比较对象的内容而不是其引用。

## （5）类型转换

若将数据类型进行“向下转换”（Narrowing Conversion）的操作（将容量较大的数据类型转换成容量较小的类型），可能会发生信息丢失的危险。

除了布尔类型的数据，Java允许任何基本类型的数据转换为另一种基本类型的数据。此外，类是不能进行类型转换的。为了将一个类转换为另一个类型，需要使用特殊的方法（后面将会学习到如何在父子类之间进行向上/向下转型，例如，“橡树”可以转换为“树”，反之亦然。而对于“岩石”是无法转换为“树”的）。

# 四、控制流

# 五、初始化和清理

# 六、封装

# 七、复用

# 八、多态

# 九、接口

# 十、内部类

一个定义在另一个类中的类，叫作内部类。内部类是一种非常有用的特性，它允许你把一些逻辑相关的类组织在一起，并控制位于内部的类的可见性。

（1）创建内部类

（2）链接外部类

当生成一个内部类的对象时，此对象与制造它的外部对象（enclosing object）之间就有了一种联系，所以它能访问其外部对象的所有成员，而不需要任何特殊条件。此外，内部类还拥有其外部类的所有元素的访问权。当某个外部类的对象创建了一个内部类对象时，此内部类对象必定会秘密地捕获一个指向那个外部类对象的引用。然后，在你访问此外部类的成员时，就是用那个引用来选择外部类的成员。

（3）使用 .this 和 .new

（4）内部类与向上转型

（5）内部类方法和作用域

# 十一、集合

如果一个程序只包含固定数量的对象且对象的生命周期都是已知的，那么这是一个非常简单的程序。通常，程序总是根据运行时才知道的某些条件去创建新的对象。在此之前，无法知道所需对象的数量甚至确切类型。为了解决这个普遍的编程问题，需要在任意时刻和任意位置创建任意数量的对象。

java.util库提供了一套相当完整的集合类（collection classes）来解决这个问题，其中基本的类型有List、Set、Queue和Map。这些类型也被称作容器类（containerclasses），但我将使用Java类库使用的术语。集合提供了完善的方法来保存对象，可以使用这些工具来解决大量的问题。

## （1）泛型和类型安全的集合

使用Java 5之前的集合的一个主要问题是编译器允许你向集合中插入不正确的类型。因为Ar-rayList保存的是Object，所以不仅可以通过ArrayList的add()方法将Apple对象放入这个集合，而且可以放入Orange对象，这无论在编译期还是运行时都不会有问题。通过使用泛型，就可以在编译期防止将错误类型的对象放置到集合中。

```java
ArrayList<Apple> apples =new ArrayList<>();

// 原先的 ArrayList apples =newArrayList(); 可理解为
ArrayList<Object> apples =new ArrayList<>();
```

有了ArrayList声明中的类型指定，编译器会阻止将Orange放入apples，允许 apple 的子类放入apples。因此，这会成为一个编译期错误而不是运行时错误。使用泛型，从List中获取元素不需要强制类型转换。因为List知道它持有什么类型，因此当调用get()时，它会替你执行转型。

## （2）基本概念

Java集合类库采用“持有对象”（holding objects）的思想，并将其分为两个不同的概念，表示为类库的基本接口：

1.集合（Collection）：一个独立元素的序列，这些元素都服从一条或多条规则。List必须以插入的顺序保存元素，Set不能包含重复元素，Queue按照排队规则来确定对象产生的顺序（通常与它们被插入的顺序相同）。

2.映射（Map）：一组成对的“键值对”对象，允许使用键来查找值。ArrayList使用数字来查找对象，因此在某种意义上讲，它是将数字和对象关联在一起。map允许我们使用一个对象来查找另一个对象，它也被称作关联数组（associative array），因为它将对象和其它对象关联在一起；或者称作字典（dictionary），因为可以使用一个键对象来查找值对象，就像在字典中使用单词查找定义一样。

## （3）

## （4）

## （5）

## （6）

## （7）

## （8）

（9）

# 十二、函数式编程

使用代码以某种方式操纵其他代码的想法也很有趣，只要能保证它更安全。从代码创建，维护和可靠性的角度来看，这个想法非常吸引人。我们不用从头开始编写大量代码，而是从易于理解、充分测试及可靠的现有小块开始，最后将它们组合在一起以创建新代码。这就是函数式编程（FP）的意义所在。通过合并现有代码来生成新功能而不是从头开始编写所有内容，我们可以更快地获得更可靠的代码。

OO（object oriented，面向对象）是抽象数据，FP（functional programming，函数式编程）是抽象行为。

纯粹的函数式语言在安全性方面更进一步。它强加了额外的约束，即所有数据必须是不可变的：设置一次，永不改变。将值传递给函数，该函数然后生成新值但从不修改自身外部的任何东西（包括其参数或该函数范围之外的元素）。当强制执行此操作时，你知道任何错误都不是由所谓的副作用引起的，因为该函数仅创建并返回结果，而不是其他任何错误。

更好的是，“不可变对象和无副作用”范式解决了并发编程中最基本和最棘手的问题之一（当程序的某些部分同时在多个处理器上运行时）。这是可变共享状态的问题，这意味着代码的不同部分（在不同的处理器上运行）可以尝试同时修改同一块内存（谁赢了？没人知道）。如果函数永远不会修改现有值但只生成新值，则不会对内存产生争用，这是纯函数式语言的定义。因此，经常提出纯函数式语言作为并行编程的解决方案（还有其他可行的解决方案）。

为“并行编程”，“代码可靠性”和“代码创建和库复用”。1关于函数式编程能高效创建更健壮的代码这一观点仍存在部分争议。虽然已有一些好的范例2，但还不足以证明纯函数式语言就是解决编程问题的最佳方法。

## （1）新旧对比

通常，传递给方法的数据不同，结果不同。如果我们希望方法在调用时行为不同，该怎么做呢？结论是：只要能将代码传递给方法，我们就可以控制它的行为。此前，我们通过在方法中创建包含所需行为的对象，然后将该对象传递给我们想要控制的方法来完成此操作。

（2）Lambda表达式

（3）方法引用

（4）函数式接口

（5）高阶函数

（6）

（7）

（8）

# 十三、流式编程

# 十四、异常

# 十五、代码校验

# 十六、文件

# 十七、字符串





