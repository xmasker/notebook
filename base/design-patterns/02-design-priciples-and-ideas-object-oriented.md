[两道Java中级/高级开发笔试题笔试题解题思路 - 简书 (jianshu.com)](https://www.jianshu.com/p/a4d7b267ddfd)

# 理论一：当谈论面向对象的时候，我们到底在谈论什么？

## 什么是面向对象编程和面向对象编程语言？

面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并 将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。 

面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面 向对象编程四大特性（封装、抽象、继承、多态）的编程语言。

一般来讲， 面向对象编程都是通过使用面向对象编程语言来进行的，但是，不用面向对象编程语言，我们照样可以进行面向对象编程。反过来讲，即便我们使用面向对象编程语言，写出来的代码也不一定是面向对象编程风格的，也有可能是面向过程编程风格的。

理解面向对象编程及面向对象编程语言两个概念， 其中最关键的一点就是理解面向对象编程的四大特性。这四大特性分别是：封装、抽象、继承、多态。

## 如何判定某编程语言是否是面向对象编程语言？

如果不按照严格的定 义来说，大部分编程语言都是面向对象编程语言。比如 JavaScript，它不支持封装和继承特性，按照严格的定义，它不算是面向对象编程语言，但在某种意义上，它 又可以算得上是一种面向对象编程语言。

实际上，面向对象编程从字面上，按照最简单、最原始的方式来理解，就是将对象或类作为 代码组织的基本单元，来进行编程的一种编程范式或者编程风格，并不一定需要封装、抽 象、继承、多态这四大特性的支持。但是，在进行面向对象编程的过程中，人们不停地总结 发现，有了这四大特性，我们就能更容易地实现各种面向对象的代码设计思路。

比如，我们在面向对象编程的过程中，经常会遇到 is-a 这种类关系（比如狗是一种动 物），而继承这个特性就能很好地支持这种 is-a 的代码设计思路，并且解决代码复用的问 题，所以，继承就成了面向对象编程的四大特性之一。但是随着编程语言的不断迭代、演 化，人们发现继承这种特性容易造成层次不清、代码混乱，所以，很多编程语言在设计的时 候就开始摒弃继承特性，比如 Go 语言。但是，我们并不能因为它摒弃了继承特性，就一刀 切地认为它不是面向对象编程语言了。

只要某种编程语言支持类或对象的语法概念，并且以此作为组织代码 的基本单元，那就可以被粗略地认为它就是面向对象编程语言了。至于是否有现成的语法机 制，完全地支持了面向对象编程的四大特性、是否对四大特性有所取舍和优化，可以不作为 判定的标准。

## 什么是面向对象分析和面向对象设计？

OOA、OOD、OOP 三个连在一起就是面向对象分析、设计、编程（实现），正好是面向对象软件开发要经历的三个阶段。

分析和设计两个阶段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些 属性方法，类与类之间如何交互等等。

面向对象分析、设计、编程到底都负责做哪些工作呢？简单点讲，面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做，面向对象编程就是将分析和设计的的结果翻译成代码的过程。

## 什么是 UML？我们是否需要 UML？ 

讲到面向对象分析、设计、编程，我们就不得不提到另外一个概念，那就是 UML（Unified Model Language），统一建模语言。很多讲解面向对象或设计模式的书籍，常用它来画图表达面向对象或设计模式的设计思路。 

实际上，UML 是一种非常复杂的东西。它不仅仅包含我们常提到类图，还有用例图、顺序 图、活动图、状态图、组件图等。即便仅仅使用类图，学习成本也是很高的。就单说类之间的关系，UML 就定义了很多种，比如泛化、实现、关联、聚合、组合、依赖等。 要想完全掌握，并且熟练运用这些类之间的关系，来画 UML 类图，肯定要花很多的学习精力。而且，UML 作为一种沟通工具，即便你能完全按照 UML 规范来画类图，可对于不熟悉的人来说，看懂的成本也还是很高的。

UML 在互联网公司的项目开发中，用处可能并不大。为了文档化软件设计或者方便讨论软件设计，大部分情况下，我们随手画个不那么规范的草图，能够达意，方便沟通就够了，而完全按照 UML 规范来将草图标准化，所付出的代价是不值得的。



# 理论二：封装、抽象、继承、多态分别可以解决哪些编程问题？

理解面向对象编程及面向对象编程语言 的关键就是理解其四大特性：封装、抽象、继承、多态。不过，对于这四大特性，光知道它们的定义是不够的，我们还要知道每个特性存在的意义和目的，以及它们能解决哪些编程问 题。

对于这四大特性，尽管大部分面向对象编程语言都提供了相应的语法机 制来支持，但不同的编程语言实现这四大特性的语法机制可能会有所不同。

## 封装（Encapsulation）

封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问 接口，授权外部仅能通过类提供的方式（或者叫函数）来访问内部信息或者数据。它需要编程语言提供权限访问控制语法来支持，例如 Java 中的 private、protected、public 关键字。封装特性存在的意义，一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用 性。

下面这段代码是金融系统中一个简化版的虚拟钱包的代码实现。在金融系统中，我们会给每 个用户创建一个虚拟钱包，用来记录用户在我们的系统中的虚拟货币量。

Wallet 类主要有四个属性（也可以叫作成员变量），也就是我 们前面定义中提到的信息或者数据。其中，id 表示钱包的唯一编号，createTime 表示钱包 创建的时间，balance 表示钱包中的余额，balanceLastModifiedTime 表示上次钱包余额 变更的时间。 

我们参照封装特性，对钱包的这四个属性的访问方式进行了限制（private）。调用者只允许通过下面这六个方法来访问或者修改钱包里的数据。

String getId() 

long getCreateTime() 

BigDecimal getBalance() 

long getBalanceLastModifiedTime() 

void increaseBalance(BigDecimal increasedAmount) 

void decreaseBalance(BigDecimal decreasedAmount)

为从业务的角度来说，id、createTime 在创建钱包的时候就确定好 了，之后不应该再被改动，所以，我们并没有在 Wallet 类中，暴露 id、createTime 这两 个属性的任何修改方法，比如 set 方法。而且，这两个属性的初始化设置，对于 Wallet 类 的调用者来说，也应该是透明的，所以，我们在 Wallet 类的构造函数内部将其初始化设置 好，而不是通过构造函数的参数来外部赋值。

对于钱包余额 balance 这个属性，从业务的角度来说，只能增或者减，不会被重新设置。 所以，我们在 Wallet 类中，只暴露了 increaseBalance() 和 decreaseBalance() 方法，并 没有暴露 set 方法。对于 balanceLastModifiedTime 这个属性，它完全是跟 balance 这 个属性的修改操作绑定在一起的。只有在 balance 修改的时候，这个属性才会被修改。所 以，我们把 balanceLastModifiedTime 这个属性的修改操作完全封装在了 increaseBalance() 和 decreaseBalance() 两个方法中，不对外暴露任何修改这个属性的方法和业务细节。这样也可以保证 balance 和 balanceLastModifiedTime 两个数据的一致性。

对于封装这个特性，我们需要编程语言本身提供一定的语法机制来支持。这个语法机制就是 **访问权限控制**。例子中的 private、public 等关键字就是 Java 语言中的访问权限控制语 法。private 关键字修饰的属性只能类本身访问，可以保护其不被类之外的代码直接访问。 如果 Java 语言没有提供访问权限控制语法，所有的属性默认都是 public 的，那任意外部 代码都可以通过类似 wallet.id=123; 这样的方式直接访问、修改属性，也就没办法达到隐 藏信息和保护数据的目的了，也就无法支持封装特性了。

**封装特性的定义讲完了，我们再来看一下，封装的意义是什么？它能解决什么编程问题？**

如果我们对类中属性的访问不做限制，那任何代码都可以访问、修改类中的属性，虽然这样 看起来更加灵活，但从另一方面来说，过度灵活也意味着不可控，属性可以随意被以各种奇 葩的方式修改，而且修改逻辑可能散落在代码中的各个角落，势必影响代码的可读性、可维 护性。比如某个同事在不了解业务逻辑的情况下，在某段代码中“偷偷地”重设了 wallet 中的 balanceLastModifiedTime 属性，这就会导致 balance 和 balanceLastModifiedTime 两个数据不一致。

除此之外，类仅仅通过有限的方法暴露必要的操作，也能提高类的易用性。如果我们把类属 性都暴露给类的调用者，调用者想要正确地操作这些属性，就势必要对业务细节有足够的了 解。而这对于调用者来说也是一种负担。相反，如果我们将属性封装起来，暴露少许的几个 必要的方法给调用者使用，调用者就不需要了解太多背后的业务细节，用错的概率就减少很多。



**c 语言通过结构体来实现封装**，只是c 的结构体没有关键字来控制结构体内部成员的访问权限问题，属于一种比较粗的封装。另外C中通过void*+结构体+函数指针也是可以实现多太的。Linux内核代码好多都是用了面向对象编程思想。C++中引入public protected privat e 关键字来进行访问控制权管理。C++中没有Java中的interface 关键字来描述接口类，但 也是可以通过虚函数基类来进行的Java中的接口类的。C++是直接支持多继承的，但这…

## 抽象（Abstraction）

 封装主要讲的是如何隐藏信息、保护数据，而抽象讲的是如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。

在面向对象编程中，我们常借助编程语言提供的接口类（比如 Java 中的 interface 关键字 语法）或者抽象类（比如 Java 中的 abstract 关键字语法）这两种语法机制，来实现抽象这一特性，但也并不需要特殊的语法机制来支持。抽象存在的意义，一方面是提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围；另一方面，它也 是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。

把编程语言提供的接口语法叫作“接口类”而不是“接口”。之所以这么做，是因为“接口”这个词太泛化，可以指好多概念，比如 API 接口等，所以，我们用“接口类”特指编程语言提供的接口语法。

```java
public interface IPictureStorage {
    void savePicture(Picture picture);
    Image getPicture(String pictureId);
    void deletePicture(String pictureId);
    void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo);
}
public class PictureStorage implements IPictureStorage {
    // ... 省略其他属性...
    @Override
    public void savePicture(Picture picture) { ... }
    @Override
    public Image getPicture(String pictureId) { ... }
    @Override
    public void deletePicture(String pictureId) { ... }
    @Override
    public void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo) { ...
}

```

在上面的这段代码中，我们利用 Java 中的 interface 接口语法来实现抽象特性。调用者在 使用图片存储功能的时候，只需要了解 IPictureStorage 这个接口类暴露了哪些方法就可以 了，不需要去查看 PictureStorage 类里的具体实现逻辑。

实际上，抽象这个特性是非常容易实现的，并不需要非得依靠接口类或者抽象类这些特殊语 法机制来支持。换句话说，并不是说一定要为实现类（PictureStorage）抽象出接口类 （IPictureStorage），才叫作抽象。即便不编写 IPictureStorage 接口类，单纯的 PictureStorage 类本身就满足抽象特性。

之所以这么说，那是因为，类的方法是通过编程语言中的“函数”这一语法机制来实现的。 通过函数包裹具体的实现逻辑，这本身就是一种抽象。调用者在使用函数的时候，并不需要去研究函数内部的实现逻辑，只需要通过函数的命名、注释或者文档，了解其提供了什么功 能，就可以直接使用了。比如，我们在使用 C 语言的 malloc() 函数的时候，并不需要了解它的底层代码是怎么实现的。

抽象有时候会被排除在面向对象的四大特性之外， 当时我卖了一个关子，现在我就来解释一下为什么。 抽象这个概念是一个非常通用的设计思想，并不单单用在面向对象编程中，也可以用来指导架构设计等。而且这个特性也并不需要编程语言提供特殊的语法机制来支持，只需要提供“函数”这一非常基础的语法机制，就可以实现抽象特性、所以，它没有很强的“特异性”，有时候并不被看作面向对象编程的特性之一。

**抽象特性的定义讲完了，我们再来看一下，抽象的意义是什么？它能解决什么编程问题？**

实际上，如果上升一个思考层面的话，抽象及其前面讲到的封装都是人类处理复杂性的有效 手段。在面对复杂系统的时候，人脑能承受的信息复杂程度是有限的，所以我们必须忽略掉 一些非关键性的实现细节。而抽象作为一种只关注功能点不关注实现的设计思路，正好帮我 们的大脑过滤掉许多非必要的信息。

除此之外，抽象作为一个非常宽泛的设计思想，在代码设计中，起到非常重要的指导作用。 很多设计原则都体现了抽象这种设计思想，比如基于接口而非实现编程、开闭原则（对扩展 开放、对修改关闭）、代码解耦（降低代码的耦合性）等。

换一个角度来考虑，我们在定义（或者叫命名）类的方法的时候，也要有抽象思维，不要在 方法定义中，暴露太多的实现细节，以保证在某个时间点需要改变方法的实现逻辑的时候， 不用去修改其定义。举个简单例子，比如 getAliyunPictureUrl() 就不是一个具有抽象思维 的命名，因为某一天如果我们不再把图片存储在阿里云上，而是存储在私有云上，那这个命 名也要随之被修改。相反，如果我们定义一个比较抽象的函数，比如叫作 getPictureUrl()，那即便内部存储方式修改了，我们也不需要修改命名。

## 继承（Inheritance）

继承是用来表示类之间的 is-a 关系，比如猫是一种哺乳动物。从继承关系上来讲，继承可以分为两种模式，单继承 和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类， 比如猫既是哺乳动物，又是爬行动物。

为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持，比如 Java 使用 extends 关键字来实现继承，C++ 使用冒号（class B : public A），Python 使用 paraentheses()，Ruby 使用 <。不过，有些编程语言只支持单继承，不支持多重继承，比 如 Java、PHP、C#、Ruby 等，而有些编程语言既支持单重继承，也支持多重继承，比如 C++、Python、Perl 等。

**继承特性的定义讲完了，我们再来看，继承存在的意义是什么？它能解决什么编程问题？**

继承最大的一个好处就是代码复用。假如两个类有一些相同的属性和方法，我们就可以将这 些相同的部分，抽取到父类中，让两个子类继承父类。这样，两个子类就可以重用父类中的 代码，避免代码重复写多遍。不过，这一点也并不是继承所独有的，我们也可以通过其他方 式来解决这个代码复用的问题，比如利用组合关系而不是继承关系。

如果我们再上升一个思维层面，去思考继承这一特性，可以这么理解：我们代码中有一个猫 类，有一个哺乳动物类。猫属于哺乳动物，从人类认知的角度上来说，是一种 is-a 关系。 我们通过继承来关联两个类，反应真实世界中的这种关系，非常符合人类的认知，而且，从 设计的角度来说，也有一种结构美感。 

继承的概念很好理解，也很容易使用。不过，过度使用继承，继承层次过深过复杂，就会导 致代码可读性、可维护性变差。为了了解一个类的功能，我们不仅需要查看这个类的代码， 还需要按照继承关系一层一层地往上查看“父类、父类的父类……”的代码。还有，子类和 父类高度耦合，修改父类的代码，会直接影响到子类。 

所以，继承这个特性也是一个非常有争议的特性。很多人觉得继承是一种反模式。我们应该 尽量少用，甚至不用。关于这个问题，在后面讲到“多用组合少用继承”这种设计思想的时 候，我会非常详细地再讲解，这里暂时就不展开讲解了。



**Java 不支持多重继承的原因** 多重继承有副作用：钻石问题(菱形继承)。 假设类 B 和类 C 继承自类 A，且都重写了类 A 中的同一个方法，而类 D 同时继承了类 B 和类 C，那么此时类 D 会继承 B、C 的方法，那对于 B、C 重写的 A 中的方法，类 D 会继 承哪一个呢？这里就会产生歧义。

## 多态（Polymorphism）

多态是指，子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。多态这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类、duck-typing。多态可 以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。

```java
public class DynamicArray {
    private static final int DEFAULT_CAPACITY = 10;
    protected int size = 0;
    protected int capacity = DEFAULT_CAPACITY;
    protected Integer[] elements = new Integer[DEFAULT_CAPACITY];
    public int size() { return this.size; }
    public Integer get(int index) { return elements[index];}
    //... 省略 n 多方法...
    public void add(Integer e) {
        ensureCapacity();
        elements[size++] = e;
	}
	protected void ensureCapacity() {
	//... 如果数组满了就扩容... 代码省略...
	}
}

public class SortedDynamicArray extends DynamicArray {
    @Override
    public void add(Integer e) {
        ensureCapacity();
        for (int i = size-1; i>=0; --i) { // 保证数组中的数据有序
            if (elements[i] > e) {
                elements[i+1] = elements[i];
            } else {
                break;
            }
        }
        elements[i+1] = e;
        ++size;
    }
}

public class Example {
    public static void test(DynamicArray dynamicArray) {
        dynamicArray.add(5);
        dynamicArray.add(1);
        dynamicArray.add(3);
        for (int i = 0; i < dynamicArray.size(); ++i) {
        	System.out.println(dynamicArray[i]);
		}
	}

	public static void main(String args[]) {
        DynamicArray dynamicArray = new SortedDynamicArray();
        test(dynamicArray); // 打印结果：1、3、5
	}
}

```

多态这种特性也需要编程语言提供特殊的语法机制来实现。在上面的例子中，我们用到了三 个语法机制来实现多态。

第一个语法机制是编程语言要支持父类对象可以引用子类对象，也就是可以将 SortedDynamicArray 传递给 DynamicArray。 

第二个语法机制是编程语言要支持继承，也就是 SortedDynamicArray 继承了 DynamicArray，才能将 SortedDyamicArray 传递给 DynamicArray。 

第三个语法机制是编程语言要支持子类可以重写（override）父类中的方法，也就是 SortedDyamicArray 重写了 DynamicArray 中的 add() 方法。

通过这三种语法机制配合在一起，我们就实现了在 test() 方法中，子类 SortedDyamicArray 替换父类 DynamicArray，执行子类 SortedDyamicArray 的 add() 方法，也就是实现了多态特性。

对于多态特性的实现方式，除了利用“继承加方法重写”这种实现方式之外，我们还有其他 两种比较常见的的实现方式，一个是利用接口类语法，另一个是利用 duck-typing 语法。 不过，并不是每种编程语言都支持接口类或者 duck-typing 这两种语法机制，比如 C++ 就不支持接口类语法，而 duck-typing 只有一些动态语言才支持，比如 Python、 JavaScript 等。

**接下来，我们先来看如何利用接口类来实现多态特性。**

```java
public interface Iterator {
    String hasNext();
    String next();
    String remove();
}

public class Array implements Iterator {
    private String[] data;
    public String hasNext() { ... }
    public String next() { ... }
    public String remove() { ... }
    //... 省略其他方法...
}

public class LinkedList implements Iterator {
    private LinkedListNode head;
    public String hasNext() { ... }
    public String next() { ... }
    public String remove() { ... }
    //... 省略其他方法...
}

public class Demo {
    private static void print(Iterator iterator) {
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }
	}
    
    public static void main(String[] args) {
        Iterator arrayIterator = new Array();
        print(arrayIterator);
        Iterator linkedListIterator = new LinkedList();
        print(linkedListIterator);
    }
}

```

在这段代码中，Iterator 是一个接口类，定义了一个可以遍历集合数据的迭代器。Array 和 LinkedList 都实现了接口类 Iterator。我们通过传递不同类型的实现类（Array、 LinkedList）到 print(Iterator iterator) 函数中，支持动态的调用不同的 next()、 hasNext() 实现。 

具体点讲就是，当我们往 print(Iterator iterator) 函数传递 Array 类型的对象的时候， print(Iterator iterator) 函数就会调用 Array 的 next()、hasNext() 的实现逻辑；当我们往 print(Iterator iterator) 函数传递 LinkedList 类型的对象的时候，print(Iterator iterator) 函数就会调用 LinkedList 的 next()、hasNext() 的实现逻辑。

**刚刚讲的是用接口类来实现多态特性。现在，我们再来看下，如何用 duck-typing 来实现多态特性。**我们还是先来看一段代码。这是一段 Python 代码。

```python
class Logger:
    def record(self):
    	print(“I write a log into file.”)
        
class DB:
    def record(self):
    	print(“I insert data into db. ”)
        
def test(recorder):
	recorder.record()
    
def demo():
    logger = Logger()
    db = DB()
    test(logger)
    test(db)
```

duck-typing 实现多态的方式非常灵活。Logger 和 DB 两个类 没有任何关系，既不是继承关系，也不是接口和实现的关系，但是只要它们都有定义了 record() 方法，就可以被传递到 test() 方法中，在实际运行的时候，执行对应的 record() 方法。

也就是说，只要两个类具有相同的方法，就可以实现多态，并不要求两个类之间有任何关 系，这就是所谓的 duck-typing，是一些动态语言所特有的语法机制。而像 Java 这样的静 态语言，通过继承实现多态特性，必须要求两个类之间有继承关系，通过接口实现多态特 性，类必须实现对应的接口。

**多态特性讲完了，我们再来看，多态特性存在的意义是什么？它能解决什么编程问题？**

多态特性能提高代码的可扩展性和复用性。为什么这么说呢？我们回过头去看讲解多态特性 的时候，举的第二个代码实例（Iterator 的例子）。 在那个例子中，我们利用多态的特性，仅用一个 print() 函数就可以实现遍历打印不同类型 （Array、LinkedList）集合的数据。当再增加一种要遍历打印的类型的时候，比如 HashMap，我们只需让 HashMap 实现 Iterator 接口，重新实现自己的 hasNext()、next() 等方法就可以了，完全不需要改动 print() 函数的代码。所以说，多态提高了代码的 可扩展性。

如果我们不使用多态特性，我们就无法将不同的集合类型（Array、LinkedList）传递给相 同的函数（print(Iterator iterator) 函数）。我们需要针对每种要遍历打印的集合，分别实 现不同的 print() 函数，比如针对 Array，我们要实现 print(Array array) 函数，针对 LinkedList，我们要实现 print(LinkedList linkedList) 函数。而利用多态特性，我们只需要 实现一个 print() 函数的打印逻辑，就能应对各种集合数据的打印操作，这显然提高了代码 的复用性。

除此之外，多态也是很多设计模式、设计原则、编程技巧的代码实现基础，比如策略模式、 基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的 if-else 语句 等等。

# 理论三：面向对象相比面向过程有哪些优势？面向过程真的过时 了吗？

除了面向对象之外，被大家熟知的编程范式还有另外两种，面向过程编程和函数式编 程。面向过程这种编程范式随着面向对象的出现，已经慢慢退出了舞台，而函数式编程目前 还没有被广泛接受。

在过往的工作中，我发现很多人搞不清楚面向对象和面向过程的区别，总以为使用 面向对象编程语言来做开发，就是在进行面向对象编程了。而实际上，他们只是在用面向对 象编程语言，编写面向过程风格的代码而已，并没有发挥面向对象编程的优势。

对比一下面向过程和面向对象这两种编程范式，搞清楚下面这几 个问题

1. 什么是面向过程编程与面向过程编程语言？ 
2. 面向对象编程相比面向过程编程有哪些优势？ 
3. 为什么说面向对象编程语言比面向过程编程语言更高级？ 
4. 有哪些看似是面向对象实际是面向过程风格的代码？ 
5. 在面向对象编程中，为什么容易写出面向过程风格的代码？ 
6. 面向过程编程和面向过程编程语言就真的无用武之地了吗？



## 什么是面向过程编程与面向过程编程语言？

面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并 将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。 

面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面 向对象编程四大特性（封装、抽象、继承、多态）的编程语言。

## 面向对象编程相比面向过程编程有哪些优势？

1.OOP 更加能够应对大规模复杂程序的开发

2.OOP 风格的代码更易复用、易扩展、易维护

3.OOP 语言更加人性化、更加高级、更加智能

# 理论四：哪些代码设计看似是面向对象，实际是面向过程的？

## 哪些代码设计看似是面向对象，实际是面向过程的？

### 1、滥用 getter、setter 方法

直接用 IDE 或者 Lombok 插件（如果 是 Java 项目的话）自动生成所有属性的 getter、setter 方法。它违反了面向对象编程的封装特性，相当于将面向 对象编程风格退化成了面向过程编程风格。

面向对象封装的定义是：通过访问权限控制，隐藏内部数据，外部仅能通过类提供的有限 的接口访问、修改内部数据。所以，暴露不应该暴露的 setter 方法，明显违反了面向对象 的封装特性。数据没有访问权限控制，任何代码都可以随意修改它，代码就退化成了面向过 程编程风格的了。

在设计实现类的时候，除非真的需要，否则，尽量不要给属性定义 setter 方法。

### 2、滥用全局变量和全局方法

在面向对象编程中，常见的全局变量有单例类对象、静态成员变量、常量等，常见的全局方 法有静态方法。单例类对象在全局代码中只有一份，所以，它相当于一个全局变量。静态成 员变量归属于类上的数据，被所有的实例化对象所共享，也相当于一定程度上的全局变量。 而常量是一种非常常见的全局变量，比如一些代码中的配置参数，一般都设置为常量，放到 一个 Constants 类中。静态方法一般用来操作静态变量或者外部数据。你可以联想一下我 们常用的各种 Utils 类，里面的方法一般都会定义成静态方法，可以在不用创建对象的情况 下，直接拿来使用。静态方法将方法与数据分离，破坏了封装特性，是典型的面向过程风格。

定义一个如此大而全的 Constants 类，并不是一种很好的设计思路。为什么这么说 呢？原因主要有以下几点。 首先，这样的设计会影响代码的可维护性。 如果参与开发同一个项目的工程师有很多，在开发过程中，可能都要涉及修改这个类，比如 往这个类里添加常量，那这个类就会变得越来越大，成百上千行都有可能，查找修改某个常 量也会变得比较费时，而且还会增加提交代码冲突的概率。 其次，这样的设计还会增加代码的编译时间。当 Constants 类中包含很多常量定义的时候，依赖这个类的代码就会很多。那每次修改 Constants 类，都会导致依赖它的类文件重新编译，因此会浪费很多不必要的编译时间。最后，这样的设计还会影响代码的复用性。们要在另一个项目中，复用本项目开发的某个类，而这个类又依赖 Constants 类。 即便这个类只依赖 Constants 类中的一小部分常量，我们仍然需要把整个 Constants 类也 一并引入，也就引入了很多无关的常量到新的项目中。

如何改进 Constants 类的设计呢？我这里有两种思路可以借鉴。 第一种是将 Constants 类拆解为功能更加单一的多个类，比如跟 MySQL 配置相关的常 量，我们放到 MysqlConstants 类中；跟 Redis 配置相关的常量，我们放到 RedisConstants 类中。当然，还有一种我个人觉得更好的设计思路，那就是并不单独地设 计 Constants 常量类，而是哪个类用到了某个常量，我们就把这个常量定义到这个类中。 12 13 14 public static final String REDIS_DEFAULT_KEY_PREFIX = "rt:"; // ... 省略更多的常量定义... } 比如，RedisConfig 类用到了 Redis 配置相关的常量，那我们就直接将这些常量定义在 RedisConfig 中，这样也提高了类设计的内聚性和代码的复用性。

Utils 类的出现是基于这样一个问题背景：如果我们有两个类 A 和 B，它们要用到 一块相同的功能逻辑，为了避免代码重复，我们不应该在两个类中，将这个相同的功能逻 辑，重复地实现两遍。这个时候我们该怎么办呢？

从业务含义上，A 类和 B 类并不一定具有继承关系，比如 Crawler 类和 PageAnalyzer 类，它们都用到了 URL 拼接和分割的功能，但并不具有继承关系（既 不是父子关系，也不是兄弟关系）。仅仅为了代码复用，生硬地抽象出一个父类出来，会影 响到代码的可读性。既然继承不能解决这个问题，我们可以定义一个新的类，实现 URL 拼接和分割的方法。而 拼接和分割两个方法，不需要共享任何数据，所以新的类不需要定义任何属性，这个时候， 我们就可以把它定义为只包含静态方法的 Utils 类了。 实际上，只包含静态方法不包含任何属性的 Utils 类，是彻彻底底的面向过程的编程风格。 但这并不是说，我们就要杜绝使用 Utils 类了。实际上，从刚刚讲的 Utils 类存在的目的来 看，它在软件开发中还是挺有用的，能解决代码复用问题。所以，这里并不是说完全不能用 Utils 类，而是说，要尽量避免滥用，不要不加思考地随意去定义 Utils 类。

除此之外，类比 Constants 类的设计，我们设计 Utils 类的时候，最好也能细化一下，针 对不同的功能，设计不同的 Utils 类，比如 FileUtils、IOUtils、StringUtils、UrlUtils 等， 不要设计一个过于大而全的 Utils 类。

### 3、定义数据和方法分离的类

再来看最后一种面向对象编程过程中，常见的面向过程风格的代码。那就是，数据定义 在一个类中，方法定义在另一个类中。你可能会觉得，这么明显的面向过程风格的代码，谁 会这么写呢？实际上，如果你是基于 MVC 三层结构做 Web 方面的后端开发，这样的代码 你可能天天都在写。

传统的 MVC 结构分为 Model 层、Controller 层、View 层这三层。不过，在做前后端分 离之后，三层结构在后端开发中，会稍微有些调整，被分为 Controller 层、Service 层、 Repository 层。Controller 层负责暴露接口给前端调用，Service 层负责核心业务逻辑， Repository 层负责数据读写。而在每一层中，我们又会定义相应的 VO（View Object）、 BO（Business Object）、Entity。一般情况下，VO、BO、Entity 中只会定义数据，不会 定义方法，所有操作这些数据的业务逻辑都定义在对应的 Controller 类、Service 类、 Repository 类中。这就是典型的面向过程的编程风格。

## 在面向对象编程中，为什么容易写出面向过程风格的代码？

在生活中，你去完成一个任务，你一般都会思考，应该先做什么、后做什 么，如何一步一步地顺序执行一系列操作，最后完成整个任务。面向过程编程风格恰恰符合 人的这种流程化思维方式。而面向对象编程风格正好相反。它是一种自底向上的思考方式。它不是先去按照执行流程来分解任务，而是将任务翻译成一个一个的小的模块（也就是 类），设计类之间的交互，最后按照流程将类组装起来，完成整个任务。

面向对象编程要比面向过程编程难一些。在面向对象编程中，类的设计还是挺需 要技巧，挺需要一定设计经验的。你要去思考如何封装合适的数据和方法到一个类里，如何 设计类之间的关系，如何设计类之间的交互等等诸多设计问题。

## 面向过程编程及面向过程编程语言就真的无用武之地了吗？

如果我们开发的是微小程序，或者是一个数据处理相关的代码，以算法为 主，数据为辅，那脚本式的面向过程的编程风格就更适合一些。当然，面向过程编程的用武 之地还不止这些。实际上，面向过程编程是面向对象编程的基础，面向对象编程离不开基础 的面向过程编程。为什么这么说？我们仔细想想，类中每个方法的实现逻辑，不就是面向过程风格的代码吗？

不管使用面向过程还是面向对象哪种风格来写代码，我们最终的目的还是写出易维护、易 读、易复用、易扩展的高质量代码。只要我们能避免面向过程编程风格的一些弊端，控制好 它的副作用，在掌控范围内为我们所用，我们就大可不用避讳在面向对象编程中写面向过程 风格的代码。

## 重点

1. 滥用 getter、setter 方法 在设计实现类的时候，除非真的需要，否则尽量不要给属性定义 setter 方法。除此之外， 尽管 getter 方法相对 setter 方法要安全些，但是如果返回的是集合容器，那也要防范集合 内部数据被修改的风险。 
2. Constants 类、Utils 类的设计问题 对于这两种类的设计，我们尽量能做到职责单一，定义一些细化的小类，比如 RedisConstants、FileUtils，而不是定义一个大而全的 Constants 类、Utils 类。除此之外，如果能将这些类中的属性和方法，划分归并到其他业务类中，那是最好不过的了，能极 大地提高类的内聚性和代码的可复用性。 
3. 基于贫血模型的开发模式关于这一部分，我们只讲了为什么这种开发模式是彻彻底底的面向过程编程风格的。这是因 为数据和操作是分开定义在 VO/BO/Entity 和 Controler/Service/Repository 中的。今天，你只需要掌握这一点就可以了。为什么这种开发模式如此流行？如何规避面向过程编程 的弊端？有没有更好的可替代的开发模式？